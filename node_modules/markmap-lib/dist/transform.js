"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.buildTree = buildTree;
exports.setPlugins = setPlugins;
exports.transform = transform;
exports.getAssets = getAssets;
exports.getUsedAssets = getUsedAssets;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _remarkable = require("remarkable");

var _plugins = require("./plugins");

exports.builtInPlugins = _plugins.plugins;

var _util = require("./util");

let md;
let assetsMap = {};
let plugins = [];
let transformHooks;
setPlugins(_plugins.plugins);

function cleanNode(node, depth = 0) {
  if (node.t === 'heading') {
    // drop all paragraphs
    node.c = node.c.filter(item => item.t !== 'paragraph');
  } else if (node.t === 'list_item') {
    var _node$p;

    // keep first paragraph as content of list_item, drop others
    node.c = node.c.filter(item => {
      if (['paragraph', 'fence'].includes(item.t)) {
        if (!node.v) {
          node.v = item.v;
          node.p = (0, _extends2.default)({}, node.p, item.p);
        }

        return false;
      }

      return true;
    });

    if (((_node$p = node.p) == null ? void 0 : _node$p.index) != null) {
      node.v = `${node.p.index}. ${node.v}`;
    }
  } else if (node.t === 'ordered_list') {
    var _node$p$start, _node$p2;

    let index = (_node$p$start = (_node$p2 = node.p) == null ? void 0 : _node$p2.start) != null ? _node$p$start : 1;
    node.c.forEach(item => {
      if (item.t === 'list_item') {
        item.p = (0, _extends2.default)({}, item.p, {
          index
        });
        index += 1;
      }
    });
  }

  if (node.c.length === 0) {
    delete node.c;
  } else {
    node.c.forEach(child => cleanNode(child, depth + 1));

    if (node.c.length === 1 && !node.c[0].v) {
      node.c = node.c[0].c;
    }
  }

  node.d = depth;
}

function buildTree(md, tokens) {
  // TODO deal with <dl><dt>
  const root = {
    t: 'root',
    d: 0,
    v: '',
    c: [],
    p: {}
  };
  const stack = [root];
  let depth = 0;

  for (const token of tokens) {
    let current = stack[stack.length - 1];

    if (token.type.endsWith('_open')) {
      const type = token.type.slice(0, -5);
      const payload = {};

      if (type === 'heading') {
        depth = token.hLevel;

        while (((_current = current) == null ? void 0 : _current.d) >= depth) {
          var _current;

          stack.pop();
          current = stack[stack.length - 1];
        }
      } else {
        var _current2;

        depth = Math.max(depth, ((_current2 = current) == null ? void 0 : _current2.d) || 0) + 1;

        if (type === 'ordered_list') {
          payload.start = token.order;
        }
      }

      const item = {
        t: type,
        d: depth,
        p: payload,
        v: '',
        c: []
      };
      current.c.push(item);
      stack.push(item);
    } else if (!current) {
      continue;
    } else if (token.type === `${current.t}_close`) {
      if (current.t === 'heading') {
        depth = current.d;
      } else {
        stack.pop();
        depth = 0;
      }
    } else if (token.type === 'inline') {
      const revoke = transformHooks.htmltag.tap(ctx => {
        const comment = ctx.result.match(/^<!--([\s\S]*?)-->$/);
        const data = comment == null ? void 0 : comment[1].trim();

        if (data === 'fold') {
          current.p.f = true;
          ctx.result = '';
        }
      });
      const text = md.renderer.render([token], md.options, {});
      revoke();
      current.v = `${current.v || ''}${text}`;
    } else if (token.type === 'fence') {
      current.c.push({
        t: token.type,
        d: depth + 1,
        v: md.renderer.render([token], md.options, {}),
        c: []
      });
    } else {// ignore other nodes
    }
  }

  return root;
}

function setPlugins(newPlugins) {
  plugins = newPlugins;
  transformHooks = (0, _plugins.createTransformHooks)();
  md = new _remarkable.Remarkable({
    html: true,
    maxNesting: Infinity
  });
  md.block.ruler.enable(['deflist']);
  md.renderer.rules.htmltag = (0, _util.wrapFunction)(md.renderer.rules.htmltag, {
    after: ctx => {
      transformHooks.htmltag.call(ctx);
    }
  });
  assetsMap = {};

  for (const {
    name,
    transform
  } of plugins) {
    assetsMap[name] = transform(transformHooks);
  }
}

function transform(content) {
  var _root$c;

  const features = {};
  transformHooks.parser.call(md, features);
  const tokens = md.parse(content || '', {});
  let root = buildTree(md, tokens);
  cleanNode(root);
  if (((_root$c = root.c) == null ? void 0 : _root$c.length) === 1) root = root.c[0];
  return {
    root,
    features
  };
}

function getAssets(keys) {
  var _keys;

  const styles = [];
  const scripts = [];
  (_keys = keys) != null ? _keys : keys = Object.keys(assetsMap);

  for (const assets of keys.map(key => assetsMap[key])) {
    if (assets) {
      if (assets.styles) styles.push(...assets.styles);
      if (assets.scripts) scripts.push(...assets.scripts);
    }
  }

  return {
    styles,
    scripts
  };
}

function getUsedAssets(features) {
  return getAssets(Object.keys(features).filter(key => features[key]));
}